# coding: utf-8

"""
    Jobbergate-API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 4.3.0a1
    Contact: info@omnivector.solutions
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Optional
from pydantic import BaseModel, Field, validator

class JobProperties(BaseModel):
    """
    Specialized model for job properties.  See more details at: https://slurm.schedmd.com/rest_api.html  # noqa: E501
    """
    account: Optional[Any] = Field(None, description="Charge resources used by this job to specified account.")
    account_gather_frequency: Optional[Any] = Field(None, description="Define the job accounting and profiling sampling intervals.")
    argv: Optional[Any] = Field(None, description="Arguments to the script.")
    array: Optional[Any] = Field(None, description="Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.")
    batch_features: Optional[Any] = Field(None, description="features required for batch script's node")
    begin_time: Optional[Any] = Field(None, description="Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.")
    burst_buffer: Optional[Any] = Field(None, description="Burst buffer specification.")
    cluster_constraints: Optional[Any] = Field(None, description="Specifies features that a federated cluster must have to have a sibling job submitted to it.")
    comment: Optional[Any] = Field(None, description="An arbitrary comment.")
    constraints: Optional[Any] = Field(None, description="node features required by job.")
    container: Optional[Any] = Field(None, description="Absolute path to OCI container bundle.")
    core_specification: Optional[Any] = Field(None, description="Count of specialized threads per node reserved by the job for system operations and not used by the application.")
    cores_per_socket: Optional[Any] = Field(None, description="Restrict node selection to nodes with at least the specified number of cores per socket.")
    cpu_binding: Optional[Any] = Field(None, description="Cpu binding")
    cpu_binding_hint: Optional[Any] = Field(None, description="Cpu binding hint")
    cpu_frequency: Optional[Any] = Field(None, description="Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).")
    cpus_per_gpu: Optional[Any] = Field(None, description="Number of CPUs requested per allocated GPU.")
    cpus_per_task: Optional[Any] = Field(None, description="Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.")
    current_working_directory: Optional[Any] = Field(None, description="Instruct Slurm to connect the batch script's standard output directly to the file name.")
    deadline: Optional[Any] = Field(None, description="Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])).")
    delay_boot: Optional[Any] = Field(None, description="Do not reboot nodes in order to satisfied this job's feature specification if the job has been eligible to run for less than this time period.")
    dependency: Optional[Any] = Field(None, description="Defer the start of this job until the specified dependencies have been satisfied completed.")
    distribution: Optional[Any] = Field(None, description="Specify alternate distribution methods for remote processes.")
    environment: Optional[Any] = Field(None, description="Dictionary of environment entries.")
    exclusive: Optional[Any] = Field(None, description="The job allocation can share nodes just other users with the 'user' option or with the 'mcs' option).")
    get_user_environment: Optional[Any] = Field(None, description="Load new login environment for user on job node.")
    gres: Optional[Any] = Field(None, description="Specifies a comma delimited list of generic consumable resources.")
    gres_flags: Optional[Any] = Field(None, description="Specify generic resource task binding options.")
    gpu_binding: Optional[Any] = Field(None, description="Requested binding of tasks to GPU.")
    gpu_frequency: Optional[Any] = Field(None, description="Requested GPU frequency.")
    gpus: Optional[Any] = Field(None, description="GPUs per job.")
    gpus_per_node: Optional[Any] = Field(None, description="GPUs per node.")
    gpus_per_socket: Optional[Any] = Field(None, description="GPUs per socket.")
    gpus_per_task: Optional[Any] = Field(None, description="GPUs per task.")
    hold: Optional[Any] = Field(None, description="Specify the job is to be submitted in a held state (priority of zero).")
    kill_on_invalid_dependency: Optional[Any] = Field(None, description="If a job has an invalid dependency, then Slurm is to terminate it.")
    licenses: Optional[Any] = Field(None, description="Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.")
    mail_type: Optional[Any] = Field(None, description="Notify user by email when certain event types occur.")
    mail_user: Optional[Any] = Field(None, description="User to receive email notification of state changes as defined by mail_type.")
    mcs_label: Optional[Any] = Field(None, description="This parameter is a group among the groups of the user.")
    memory_binding: Optional[Any] = Field(None, description="Bind tasks to memory.")
    memory_per_cpu: Optional[Any] = Field(None, description="Minimum real memory per cpu (MB).")
    memory_per_gpu: Optional[Any] = Field(None, description="Minimum memory required per allocated GPU.")
    memory_per_node: Optional[Any] = Field(None, description="Minimum real memory per node (MB).")
    minimum_cpus_per_node: Optional[Any] = Field(None, description="Minimum number of CPUs per node.")
    minimum_nodes: Optional[Any] = Field(None, description="If a range of node counts is given, prefer the smaller count.")
    name: Optional[Any] = Field(None, description="Specify a name for the job allocation.")
    nice: Optional[Any] = Field(None, description="Run the job with an adjusted scheduling priority within Slurm.")
    no_kill: Optional[Any] = Field(None, description="Do not automatically terminate a job if one of the nodes it has been allocated fails.")
    nodes: Optional[Any] = Field(None, description="Request that a minimum of nodes nodes and a maximum node count.")
    open_mode: Optional[Any] = Field(None, description="Open the output and error files using append or truncate mode as specified.")
    partition: Optional[Any] = Field(None, description="Request a specific partition for the resource allocation.")
    priority: Optional[Any] = Field(None, description="Request a specific job priority.")
    qos: Optional[Any] = Field(None, description="Request a quality of service for the job.")
    requeue: Optional[Any] = Field(None, description="Specifies that the batch job should eligible to being requeue.")
    reservation: Optional[Any] = Field(None, description="Allocate resources for the job from the named reservation.")
    signal: Optional[Any] = Field(None, description="When a job is within sig_time seconds of its end time, send it the signal sig_num.")
    sockets_per_node: Optional[Any] = Field(None, description="Restrict node selection to nodes with at least the specified number of sockets.")
    spread_job: Optional[Any] = Field(None, description="Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.")
    standard_error: Optional[Any] = Field(None, description="Instruct Slurm to connect the batch script's standard error directly to the file name.")
    standard_input: Optional[Any] = Field(None, description="Instruct Slurm to connect the batch script's standard input directly to the file name specified.")
    standard_output: Optional[Any] = Field(None, description="Instruct Slurm to connect the batch script's standard output directly to the file name.")
    tasks: Optional[Any] = Field(None, description="Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.")
    tasks_per_core: Optional[Any] = Field(None, description="Request the maximum ntasks be invoked on each core.")
    tasks_per_node: Optional[Any] = Field(None, description="Request the maximum ntasks be invoked on each node.")
    tasks_per_socket: Optional[Any] = Field(None, description="Request the maximum ntasks be invoked on each socket.")
    thread_specification: Optional[Any] = Field(None, description="Count of specialized threads per node reserved by the job for system operations and not used by the application.")
    threads_per_core: Optional[Any] = Field(None, description="Restrict node selection to nodes with at least the specified number of threads per core.")
    time_limit: Optional[Any] = Field(None, description="Step time limit.")
    time_minimum: Optional[Any] = Field(None, description="Minimum run time in minutes.")
    wait_all_nodes: Optional[Any] = Field(None, description="Do not begin execution until all nodes are ready for use.")
    wckey: Optional[Any] = Field(None, description="Specify wckey to be used with job.")
    additional_properties: Dict[str, Any] = {}
    __properties = ["account", "account_gather_frequency", "argv", "array", "batch_features", "begin_time", "burst_buffer", "cluster_constraints", "comment", "constraints", "container", "core_specification", "cores_per_socket", "cpu_binding", "cpu_binding_hint", "cpu_frequency", "cpus_per_gpu", "cpus_per_task", "current_working_directory", "deadline", "delay_boot", "dependency", "distribution", "environment", "exclusive", "get_user_environment", "gres", "gres_flags", "gpu_binding", "gpu_frequency", "gpus", "gpus_per_node", "gpus_per_socket", "gpus_per_task", "hold", "kill_on_invalid_dependency", "licenses", "mail_type", "mail_user", "mcs_label", "memory_binding", "memory_per_cpu", "memory_per_gpu", "memory_per_node", "minimum_cpus_per_node", "minimum_nodes", "name", "nice", "no_kill", "nodes", "open_mode", "partition", "priority", "qos", "requeue", "reservation", "signal", "sockets_per_node", "spread_job", "standard_error", "standard_input", "standard_output", "tasks", "tasks_per_core", "tasks_per_node", "tasks_per_socket", "thread_specification", "threads_per_core", "time_limit", "time_minimum", "wait_all_nodes", "wckey"]

    @validator('exclusive')
    def exclusive_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('user', 'mcs', 'exclusive', 'oversubscribe'):
            raise ValueError("must be one of enum values ('user', 'mcs', 'exclusive', 'oversubscribe')")
        return value

    @validator('gres_flags')
    def gres_flags_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('disable-binding', 'enforce-binding'):
            raise ValueError("must be one of enum values ('disable-binding', 'enforce-binding')")
        return value

    @validator('open_mode')
    def open_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('append', 'truncate'):
            raise ValueError("must be one of enum values ('append', 'truncate')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> JobProperties:
        """Create an instance of JobProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "additional_properties"
                          },
                          exclude_none=True)
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        # set to None if account (nullable) is None
        # and __fields_set__ contains the field
        if self.account is None and "account" in self.__fields_set__:
            _dict['account'] = None

        # set to None if account_gather_frequency (nullable) is None
        # and __fields_set__ contains the field
        if self.account_gather_frequency is None and "account_gather_frequency" in self.__fields_set__:
            _dict['account_gather_frequency'] = None

        # set to None if argv (nullable) is None
        # and __fields_set__ contains the field
        if self.argv is None and "argv" in self.__fields_set__:
            _dict['argv'] = None

        # set to None if array (nullable) is None
        # and __fields_set__ contains the field
        if self.array is None and "array" in self.__fields_set__:
            _dict['array'] = None

        # set to None if batch_features (nullable) is None
        # and __fields_set__ contains the field
        if self.batch_features is None and "batch_features" in self.__fields_set__:
            _dict['batch_features'] = None

        # set to None if begin_time (nullable) is None
        # and __fields_set__ contains the field
        if self.begin_time is None and "begin_time" in self.__fields_set__:
            _dict['begin_time'] = None

        # set to None if burst_buffer (nullable) is None
        # and __fields_set__ contains the field
        if self.burst_buffer is None and "burst_buffer" in self.__fields_set__:
            _dict['burst_buffer'] = None

        # set to None if cluster_constraints (nullable) is None
        # and __fields_set__ contains the field
        if self.cluster_constraints is None and "cluster_constraints" in self.__fields_set__:
            _dict['cluster_constraints'] = None

        # set to None if comment (nullable) is None
        # and __fields_set__ contains the field
        if self.comment is None and "comment" in self.__fields_set__:
            _dict['comment'] = None

        # set to None if constraints (nullable) is None
        # and __fields_set__ contains the field
        if self.constraints is None and "constraints" in self.__fields_set__:
            _dict['constraints'] = None

        # set to None if container (nullable) is None
        # and __fields_set__ contains the field
        if self.container is None and "container" in self.__fields_set__:
            _dict['container'] = None

        # set to None if core_specification (nullable) is None
        # and __fields_set__ contains the field
        if self.core_specification is None and "core_specification" in self.__fields_set__:
            _dict['core_specification'] = None

        # set to None if cores_per_socket (nullable) is None
        # and __fields_set__ contains the field
        if self.cores_per_socket is None and "cores_per_socket" in self.__fields_set__:
            _dict['cores_per_socket'] = None

        # set to None if cpu_binding (nullable) is None
        # and __fields_set__ contains the field
        if self.cpu_binding is None and "cpu_binding" in self.__fields_set__:
            _dict['cpu_binding'] = None

        # set to None if cpu_binding_hint (nullable) is None
        # and __fields_set__ contains the field
        if self.cpu_binding_hint is None and "cpu_binding_hint" in self.__fields_set__:
            _dict['cpu_binding_hint'] = None

        # set to None if cpu_frequency (nullable) is None
        # and __fields_set__ contains the field
        if self.cpu_frequency is None and "cpu_frequency" in self.__fields_set__:
            _dict['cpu_frequency'] = None

        # set to None if cpus_per_gpu (nullable) is None
        # and __fields_set__ contains the field
        if self.cpus_per_gpu is None and "cpus_per_gpu" in self.__fields_set__:
            _dict['cpus_per_gpu'] = None

        # set to None if cpus_per_task (nullable) is None
        # and __fields_set__ contains the field
        if self.cpus_per_task is None and "cpus_per_task" in self.__fields_set__:
            _dict['cpus_per_task'] = None

        # set to None if current_working_directory (nullable) is None
        # and __fields_set__ contains the field
        if self.current_working_directory is None and "current_working_directory" in self.__fields_set__:
            _dict['current_working_directory'] = None

        # set to None if deadline (nullable) is None
        # and __fields_set__ contains the field
        if self.deadline is None and "deadline" in self.__fields_set__:
            _dict['deadline'] = None

        # set to None if delay_boot (nullable) is None
        # and __fields_set__ contains the field
        if self.delay_boot is None and "delay_boot" in self.__fields_set__:
            _dict['delay_boot'] = None

        # set to None if dependency (nullable) is None
        # and __fields_set__ contains the field
        if self.dependency is None and "dependency" in self.__fields_set__:
            _dict['dependency'] = None

        # set to None if distribution (nullable) is None
        # and __fields_set__ contains the field
        if self.distribution is None and "distribution" in self.__fields_set__:
            _dict['distribution'] = None

        # set to None if exclusive (nullable) is None
        # and __fields_set__ contains the field
        if self.exclusive is None and "exclusive" in self.__fields_set__:
            _dict['exclusive'] = None

        # set to None if get_user_environment (nullable) is None
        # and __fields_set__ contains the field
        if self.get_user_environment is None and "get_user_environment" in self.__fields_set__:
            _dict['get_user_environment'] = None

        # set to None if gres (nullable) is None
        # and __fields_set__ contains the field
        if self.gres is None and "gres" in self.__fields_set__:
            _dict['gres'] = None

        # set to None if gres_flags (nullable) is None
        # and __fields_set__ contains the field
        if self.gres_flags is None and "gres_flags" in self.__fields_set__:
            _dict['gres_flags'] = None

        # set to None if gpu_binding (nullable) is None
        # and __fields_set__ contains the field
        if self.gpu_binding is None and "gpu_binding" in self.__fields_set__:
            _dict['gpu_binding'] = None

        # set to None if gpu_frequency (nullable) is None
        # and __fields_set__ contains the field
        if self.gpu_frequency is None and "gpu_frequency" in self.__fields_set__:
            _dict['gpu_frequency'] = None

        # set to None if gpus (nullable) is None
        # and __fields_set__ contains the field
        if self.gpus is None and "gpus" in self.__fields_set__:
            _dict['gpus'] = None

        # set to None if gpus_per_node (nullable) is None
        # and __fields_set__ contains the field
        if self.gpus_per_node is None and "gpus_per_node" in self.__fields_set__:
            _dict['gpus_per_node'] = None

        # set to None if gpus_per_socket (nullable) is None
        # and __fields_set__ contains the field
        if self.gpus_per_socket is None and "gpus_per_socket" in self.__fields_set__:
            _dict['gpus_per_socket'] = None

        # set to None if gpus_per_task (nullable) is None
        # and __fields_set__ contains the field
        if self.gpus_per_task is None and "gpus_per_task" in self.__fields_set__:
            _dict['gpus_per_task'] = None

        # set to None if hold (nullable) is None
        # and __fields_set__ contains the field
        if self.hold is None and "hold" in self.__fields_set__:
            _dict['hold'] = None

        # set to None if kill_on_invalid_dependency (nullable) is None
        # and __fields_set__ contains the field
        if self.kill_on_invalid_dependency is None and "kill_on_invalid_dependency" in self.__fields_set__:
            _dict['kill_on_invalid_dependency'] = None

        # set to None if licenses (nullable) is None
        # and __fields_set__ contains the field
        if self.licenses is None and "licenses" in self.__fields_set__:
            _dict['licenses'] = None

        # set to None if mail_type (nullable) is None
        # and __fields_set__ contains the field
        if self.mail_type is None and "mail_type" in self.__fields_set__:
            _dict['mail_type'] = None

        # set to None if mail_user (nullable) is None
        # and __fields_set__ contains the field
        if self.mail_user is None and "mail_user" in self.__fields_set__:
            _dict['mail_user'] = None

        # set to None if mcs_label (nullable) is None
        # and __fields_set__ contains the field
        if self.mcs_label is None and "mcs_label" in self.__fields_set__:
            _dict['mcs_label'] = None

        # set to None if memory_binding (nullable) is None
        # and __fields_set__ contains the field
        if self.memory_binding is None and "memory_binding" in self.__fields_set__:
            _dict['memory_binding'] = None

        # set to None if memory_per_cpu (nullable) is None
        # and __fields_set__ contains the field
        if self.memory_per_cpu is None and "memory_per_cpu" in self.__fields_set__:
            _dict['memory_per_cpu'] = None

        # set to None if memory_per_gpu (nullable) is None
        # and __fields_set__ contains the field
        if self.memory_per_gpu is None and "memory_per_gpu" in self.__fields_set__:
            _dict['memory_per_gpu'] = None

        # set to None if memory_per_node (nullable) is None
        # and __fields_set__ contains the field
        if self.memory_per_node is None and "memory_per_node" in self.__fields_set__:
            _dict['memory_per_node'] = None

        # set to None if minimum_cpus_per_node (nullable) is None
        # and __fields_set__ contains the field
        if self.minimum_cpus_per_node is None and "minimum_cpus_per_node" in self.__fields_set__:
            _dict['minimum_cpus_per_node'] = None

        # set to None if minimum_nodes (nullable) is None
        # and __fields_set__ contains the field
        if self.minimum_nodes is None and "minimum_nodes" in self.__fields_set__:
            _dict['minimum_nodes'] = None

        # set to None if name (nullable) is None
        # and __fields_set__ contains the field
        if self.name is None and "name" in self.__fields_set__:
            _dict['name'] = None

        # set to None if nice (nullable) is None
        # and __fields_set__ contains the field
        if self.nice is None and "nice" in self.__fields_set__:
            _dict['nice'] = None

        # set to None if no_kill (nullable) is None
        # and __fields_set__ contains the field
        if self.no_kill is None and "no_kill" in self.__fields_set__:
            _dict['no_kill'] = None

        # set to None if nodes (nullable) is None
        # and __fields_set__ contains the field
        if self.nodes is None and "nodes" in self.__fields_set__:
            _dict['nodes'] = None

        # set to None if open_mode (nullable) is None
        # and __fields_set__ contains the field
        if self.open_mode is None and "open_mode" in self.__fields_set__:
            _dict['open_mode'] = None

        # set to None if partition (nullable) is None
        # and __fields_set__ contains the field
        if self.partition is None and "partition" in self.__fields_set__:
            _dict['partition'] = None

        # set to None if priority (nullable) is None
        # and __fields_set__ contains the field
        if self.priority is None and "priority" in self.__fields_set__:
            _dict['priority'] = None

        # set to None if qos (nullable) is None
        # and __fields_set__ contains the field
        if self.qos is None and "qos" in self.__fields_set__:
            _dict['qos'] = None

        # set to None if requeue (nullable) is None
        # and __fields_set__ contains the field
        if self.requeue is None and "requeue" in self.__fields_set__:
            _dict['requeue'] = None

        # set to None if reservation (nullable) is None
        # and __fields_set__ contains the field
        if self.reservation is None and "reservation" in self.__fields_set__:
            _dict['reservation'] = None

        # set to None if signal (nullable) is None
        # and __fields_set__ contains the field
        if self.signal is None and "signal" in self.__fields_set__:
            _dict['signal'] = None

        # set to None if sockets_per_node (nullable) is None
        # and __fields_set__ contains the field
        if self.sockets_per_node is None and "sockets_per_node" in self.__fields_set__:
            _dict['sockets_per_node'] = None

        # set to None if spread_job (nullable) is None
        # and __fields_set__ contains the field
        if self.spread_job is None and "spread_job" in self.__fields_set__:
            _dict['spread_job'] = None

        # set to None if standard_error (nullable) is None
        # and __fields_set__ contains the field
        if self.standard_error is None and "standard_error" in self.__fields_set__:
            _dict['standard_error'] = None

        # set to None if standard_input (nullable) is None
        # and __fields_set__ contains the field
        if self.standard_input is None and "standard_input" in self.__fields_set__:
            _dict['standard_input'] = None

        # set to None if standard_output (nullable) is None
        # and __fields_set__ contains the field
        if self.standard_output is None and "standard_output" in self.__fields_set__:
            _dict['standard_output'] = None

        # set to None if tasks (nullable) is None
        # and __fields_set__ contains the field
        if self.tasks is None and "tasks" in self.__fields_set__:
            _dict['tasks'] = None

        # set to None if tasks_per_core (nullable) is None
        # and __fields_set__ contains the field
        if self.tasks_per_core is None and "tasks_per_core" in self.__fields_set__:
            _dict['tasks_per_core'] = None

        # set to None if tasks_per_node (nullable) is None
        # and __fields_set__ contains the field
        if self.tasks_per_node is None and "tasks_per_node" in self.__fields_set__:
            _dict['tasks_per_node'] = None

        # set to None if tasks_per_socket (nullable) is None
        # and __fields_set__ contains the field
        if self.tasks_per_socket is None and "tasks_per_socket" in self.__fields_set__:
            _dict['tasks_per_socket'] = None

        # set to None if thread_specification (nullable) is None
        # and __fields_set__ contains the field
        if self.thread_specification is None and "thread_specification" in self.__fields_set__:
            _dict['thread_specification'] = None

        # set to None if threads_per_core (nullable) is None
        # and __fields_set__ contains the field
        if self.threads_per_core is None and "threads_per_core" in self.__fields_set__:
            _dict['threads_per_core'] = None

        # set to None if time_limit (nullable) is None
        # and __fields_set__ contains the field
        if self.time_limit is None and "time_limit" in self.__fields_set__:
            _dict['time_limit'] = None

        # set to None if time_minimum (nullable) is None
        # and __fields_set__ contains the field
        if self.time_minimum is None and "time_minimum" in self.__fields_set__:
            _dict['time_minimum'] = None

        # set to None if wait_all_nodes (nullable) is None
        # and __fields_set__ contains the field
        if self.wait_all_nodes is None and "wait_all_nodes" in self.__fields_set__:
            _dict['wait_all_nodes'] = None

        # set to None if wckey (nullable) is None
        # and __fields_set__ contains the field
        if self.wckey is None and "wckey" in self.__fields_set__:
            _dict['wckey'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> JobProperties:
        """Create an instance of JobProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return JobProperties.parse_obj(obj)

        _obj = JobProperties.parse_obj({
            "account": obj.get("account"),
            "account_gather_frequency": obj.get("account_gather_frequency"),
            "argv": obj.get("argv"),
            "array": obj.get("array"),
            "batch_features": obj.get("batch_features"),
            "begin_time": obj.get("begin_time"),
            "burst_buffer": obj.get("burst_buffer"),
            "cluster_constraints": obj.get("cluster_constraints"),
            "comment": obj.get("comment"),
            "constraints": obj.get("constraints"),
            "container": obj.get("container"),
            "core_specification": obj.get("core_specification"),
            "cores_per_socket": obj.get("cores_per_socket"),
            "cpu_binding": obj.get("cpu_binding"),
            "cpu_binding_hint": obj.get("cpu_binding_hint"),
            "cpu_frequency": obj.get("cpu_frequency"),
            "cpus_per_gpu": obj.get("cpus_per_gpu"),
            "cpus_per_task": obj.get("cpus_per_task"),
            "current_working_directory": obj.get("current_working_directory"),
            "deadline": obj.get("deadline"),
            "delay_boot": obj.get("delay_boot"),
            "dependency": obj.get("dependency"),
            "distribution": obj.get("distribution"),
            "exclusive": obj.get("exclusive"),
            "get_user_environment": obj.get("get_user_environment"),
            "gres": obj.get("gres"),
            "gres_flags": obj.get("gres_flags"),
            "gpu_binding": obj.get("gpu_binding"),
            "gpu_frequency": obj.get("gpu_frequency"),
            "gpus": obj.get("gpus"),
            "gpus_per_node": obj.get("gpus_per_node"),
            "gpus_per_socket": obj.get("gpus_per_socket"),
            "gpus_per_task": obj.get("gpus_per_task"),
            "hold": obj.get("hold"),
            "kill_on_invalid_dependency": obj.get("kill_on_invalid_dependency"),
            "licenses": obj.get("licenses"),
            "mail_type": obj.get("mail_type"),
            "mail_user": obj.get("mail_user"),
            "mcs_label": obj.get("mcs_label"),
            "memory_binding": obj.get("memory_binding"),
            "memory_per_cpu": obj.get("memory_per_cpu"),
            "memory_per_gpu": obj.get("memory_per_gpu"),
            "memory_per_node": obj.get("memory_per_node"),
            "minimum_cpus_per_node": obj.get("minimum_cpus_per_node"),
            "minimum_nodes": obj.get("minimum_nodes"),
            "name": obj.get("name"),
            "nice": obj.get("nice"),
            "no_kill": obj.get("no_kill"),
            "nodes": obj.get("nodes"),
            "open_mode": obj.get("open_mode"),
            "partition": obj.get("partition"),
            "priority": obj.get("priority"),
            "qos": obj.get("qos"),
            "requeue": obj.get("requeue"),
            "reservation": obj.get("reservation"),
            "signal": obj.get("signal"),
            "sockets_per_node": obj.get("sockets_per_node"),
            "spread_job": obj.get("spread_job"),
            "standard_error": obj.get("standard_error"),
            "standard_input": obj.get("standard_input"),
            "standard_output": obj.get("standard_output"),
            "tasks": obj.get("tasks"),
            "tasks_per_core": obj.get("tasks_per_core"),
            "tasks_per_node": obj.get("tasks_per_node"),
            "tasks_per_socket": obj.get("tasks_per_socket"),
            "thread_specification": obj.get("thread_specification"),
            "threads_per_core": obj.get("threads_per_core"),
            "time_limit": obj.get("time_limit"),
            "time_minimum": obj.get("time_minimum"),
            "wait_all_nodes": obj.get("wait_all_nodes"),
            "wckey": obj.get("wckey")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


